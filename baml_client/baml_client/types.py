# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict, Field


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (0)
# #########################################################################

# #########################################################################
# Generated classes (11)
# #########################################################################

class CredibilityAssessment(BaseModel):
    post_id: str = Field(description='ID of the post being assessed')
    credibility_score: float = Field(description='Overall credibility score (0.0 to 1.0)')
    factors: typing.List[str] = Field(description='Factors that influenced the score')
    reasoning: str = Field(description='Explanation for the assigned score')

class Event(BaseModel):
    timestamp: str = Field(description='ISO 8601 format timestamp of when event occurred')
    summary: str = Field(description='Brief description of event')
    sources: typing.List[str] = Field(description='List of X post IDs or URLs as sources for this event')
    media: typing.Optional[str] = Field(default=None, description='Optional image or video URL associated with event')
    credibility_score: float = Field(description='0.0 to 1.0, higher is more credible')
    verified_sources: int = Field(description='Number of sources verified against knowledge base')

class FollowUpQuestion(BaseModel):
    question: str = Field(description='A natural follow-up question to continue the conversation')
    category: str = Field(description='Category: \'deep_dive\', \'related_topic\', \'verification\', \'prediction\', \'comparison\'')
    context_hint: str = Field(description='Brief hint about what this question explores')
    priority: int = Field(description='Priority 1-5, where 1 is most relevant')

class KnowledgeFact(BaseModel):
    fact_id: str = Field(description='Unique identifier for this fact')
    statement: str = Field(description='The factual statement')
    sources: typing.List[str] = Field(description='Sources that verify this fact')
    verification_status: str = Field(description='One of: \'verified\', \'disputed\', or \'unverified\'')
    verified_at: str = Field(description='ISO timestamp when this fact was verified')

class MisinformationAnalysis(BaseModel):
    is_suspicious: bool
    suspicious_patterns: typing.List[str]
    risk_level: str = Field(description='low, medium, or high')
    recommendation: str

class ProcessedQuery(BaseModel):
    original_query: str = Field(description='The original user query')
    rewritten_query: str = Field(description='Optimized query for searching')
    entities: typing.List[str] = Field(description='Extracted entities from query')
    time_range: typing.Optional[str] = Field(default=None, description='Inferred time range if any')

class Recommendation(BaseModel):
    action: str = Field(description='Suggested action or follow-up query')
    reason: str = Field(description='Why this recommendation is being made')

class SessionMemory(BaseModel):
    session_id: str = Field(description='Unique session identifier')
    query: str = Field(description='The query that was made')
    timestamp: str = Field(description='ISO timestamp of when query was made')
    results_count: int = Field(description='Number of results returned for query')
    relevance_score: float = Field(description='Relevance score of results (0.0 to 1.0)')

class SimpleEvent(BaseModel):
    id: str
    summary: str

class Timeline(BaseModel):
    topic: str = Field(description='The topic or query this timeline addresses')
    events: typing.List["Event"] = Field(description='Chronological list of events')
    total_sources: int = Field(description='Total number of unique sources across all events')
    avg_credibility: float = Field(description='Average credibility score across all events')
    predictions: typing.Optional[typing.List[str]] = Field(default=None, description='Optional what-if predictions based on observed patterns')

class XPost(BaseModel):
    tweet_id: str = Field(description='Unique X post identifier')
    text: str = Field(description='Content of post')
    author: str = Field(description='Username of author')
    timestamp: str = Field(description='ISO timestamp when post was created')
    fave_count: int = Field(description='Number of favorites/likes')
    retweet_count: int = Field(description='Number of retweets')
    is_verified: bool = Field(description='Whether author is verified')
    media_urls: typing.List[str] = Field(description='List of media URLs (images, videos)')
    location: typing.Optional[str] = Field(default=None, description='Optional location tag')
    credibility_score: float = Field(description='Calculated credibility score (0.0 to 1.0)')

# #########################################################################
# Generated type aliases (0)
# #########################################################################
