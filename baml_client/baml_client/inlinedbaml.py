# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "client<llm> GeminiFlash {\n  provider google-ai\n  options {\n    model gemini-2.5-flash\n    api_key env.GOOGLE_API_KEY\n  }\n}",
    "generators.baml": "generator lang_python {\n  output_type python/pydantic\n  output_dir \"../baml_client\"\n  version \"0.217.0\"\n}",
    "main.baml": "class Event {\n  timestamp string @description(\"ISO 8601 format timestamp of when event occurred\")\n  summary string @description(\"Brief description of event\")\n  sources string[] @description(\"List of X post IDs or URLs as sources for this event\")\n  media string? @description(\"Optional image or video URL associated with event\")\n  credibility_score float @description(\"0.0 to 1.0, higher is more credible\")\n  verified_sources int @description(\"Number of sources verified against knowledge base\")\n}\n\nclass Timeline {\n  topic string @description(\"The topic or query this timeline addresses\")\n  events Event[] @description(\"Chronological list of events\")\n  total_sources int @description(\"Total number of unique sources across all events\")\n  avg_credibility float @description(\"Average credibility score across all events\")\n  predictions string[]? @description(\"Optional what-if predictions based on observed patterns\")\n}\n\nclass KnowledgeFact {\n  fact_id string @description(\"Unique identifier for this fact\")\n  statement string @description(\"The factual statement\")\n  sources string[] @description(\"Sources that verify this fact\")\n  verification_status string @description(\"One of: 'verified', 'disputed', or 'unverified'\")\n  verified_at string @description(\"ISO timestamp when this fact was verified\")\n}\n\nclass Recommendation {\n  action string @description(\"Suggested action or follow-up query\")\n  reason string @description(\"Why this recommendation is being made\")\n}\n\nclass SessionMemory {\n  session_id string @description(\"Unique session identifier\")\n  query string @description(\"The query that was made\")\n  timestamp string @description(\"ISO timestamp of when query was made\")\n  results_count int @description(\"Number of results returned for query\")\n  relevance_score float @description(\"Relevance score of results (0.0 to 1.0)\")\n}\n\nclass XPost {\n  tweet_id string @description(\"Unique X post identifier\")\n  text string @description(\"Content of post\")\n  author string @description(\"Username of author\")\n  timestamp string @description(\"ISO timestamp when post was created\")\n  fave_count int @description(\"Number of favorites/likes\")\n  retweet_count int @description(\"Number of retweets\")\n  is_verified bool @description(\"Whether author is verified\")\n  media_urls string[] @description(\"List of media URLs (images, videos)\")\n  location string? @description(\"Optional location tag\")\n  credibility_score float @description(\"Calculated credibility score (0.0 to 1.0)\")\n}\n\nclass ProcessedQuery {\n  original_query string @description(\"The original user query\")\n  rewritten_query string @description(\"Optimized query for searching\")\n  entities string[] @description(\"Extracted entities from query\")\n  time_range string? @description(\"Inferred time range if any\")\n}\n\nclass CredibilityAssessment {\n  post_id string @description(\"ID of the post being assessed\")\n  credibility_score float @description(\"Overall credibility score (0.0 to 1.0)\")\n  factors string[] @description(\"Factors that influenced the score\")\n  reasoning string @description(\"Explanation for the assigned score\")\n}\n\nclass MisinformationAnalysis {\n  is_suspicious bool\n  suspicious_patterns string[]\n  risk_level string @description(\"low, medium, or high\")\n  recommendation string\n}\n\nfunction GenerateTimeline(query: string, retrieved_context: string, num_events: int) -> Timeline {\n  client GeminiFlash\n  prompt #\"\n    You are building a factual, chronological timeline for topic: {{ query }}\n\n    Below is retrieved context from verified X posts and knowledge base:\n\n    {{ retrieved_context }}\n\n    Generate a timeline with exactly {{ num_events }} events following these strict rules:\n\n    1. CHRONOLOGICAL ORDER: Events must be in strict chronological order (earliest first)\n    2. SOURCE CITATION: Each event must cite specific sources (X post IDs or URLs)\n    3. CREDIBILITY SCORES: Assign credibility scores based on:\n       - Source verification status\n       - Author verification\n       - Engagement quality (meaningful interactions, not just spam)\n       - Consistency with known facts\n    4. ACCURACY: Be accurate and ground everything in provided context\n    5. NO HALLUCINATION: Do not invent facts. Only use information from context\n    6. UNCERTAINTY HANDLING: If information is uncertain, mark credibility score low\n    7. PREDICTIONS (Optional): Generate 2-3 what-if predictions based on observed patterns\n\n    Return as a Timeline object with all required fields:\n    - topic: The main topic of this timeline\n    - events: Array of Event objects (each with timestamp, summary, sources, credibility_score, etc.)\n    - total_sources: Total unique sources across all events\n    - avg_credibility: Average credibility across all events (0.0 to 1.0)\n    - predictions: Optional array of predictions based on patterns\n\n    Format your response as valid JSON that matches the Timeline schema.\n  \"#\n}\n\nfunction ProcessQuery(original_query: string, context: string?) -> ProcessedQuery {\n  client GeminiFlash\n  prompt #\"\n    The user asked: {{ original_query }}\n\n    {% if context %}\n    Previous context: {{ context }}\n    {% endif %}\n\n    Rewrite this query to be more precise for searching X posts and knowledge base.\n    Focus on:\n    1. Specific entities (people, organizations, locations, events)\n    2. Time ranges if implied\n    3. Key themes or topics\n    4. Disambiguation (e.g., which \"Mumbai\" - city, district, etc.)\n\n    The rewritten query should be optimized for:\n    - Vector similarity search\n    - Keyword matching\n    - Metadata filtering\n\n    Extract the main entities mentioned.\n    Identify any implicit time ranges.\n\n    Return as a ProcessedQuery object with:\n    - original_query: The original query as provided\n    - rewritten_query: The optimized query\n    - entities: Array of key entities extracted\n    - time_range: Optional inferred time range if mentioned\n\n    Return only the object, nothing else.\n  \"#\n}\n\nfunction ExtractEntities(text: string) -> string[] {\n  client GeminiFlash\n  prompt #\"\n    Extract key entities from this text:\n\n    {{ text }}\n\n    Entities can be:\n    - People (names, roles)\n    - Organizations\n    - Locations (cities, regions, countries)\n    - Events (specific incidents, announcements)\n    - Dates and times\n    - Topics or themes\n\n    Return as an array of entity names, most important first (max 10 entities).\n    Only return the entity names, nothing else.\n  \"#\n}\n\nfunction AssessCredibility(post_text: string, author_info: string, engagement: string, knowledge_context: string?) -> CredibilityAssessment {\n  client GeminiFlash\n  prompt #\"\n    Assess the credibility of this X post:\n\n    POST CONTENT:\n    {{ post_text }}\n\n    AUTHOR INFO:\n    {{ author_info }}\n\n    ENGAGEMENT METRICS:\n    {{ engagement }}\n\n    {% if knowledge_context %}\n    CONTEXT FROM VERIFIED KNOWLEDGE BASE:\n    {{ knowledge_context }}\n    {% endif %}\n\n    Consider these factors when assessing credibility:\n\n    1. AUTHOR VERIFICATION:\n       - Is the author verified?\n       - Does the author have a history of credible posts?\n       - Is the author affiliated with a reputable organization?\n\n    2. CONTENT QUALITY:\n       - Does the content make factual claims or opinions?\n       - Is it specific with verifiable details (times, locations, names)?\n       - Does it cite sources or provide evidence?\n\n    3. ENGAGEMENT QUALITY:\n       - Is engagement organic or suspicious (botted)?\n       - Are comments/replies constructive or spammy?\n       - High-quality engagement from credible users increases credibility\n\n    4. CONSISTENCY:\n       - Is it consistent with known facts?\n       - Does it contradict verified information?\n       - Does it align with multiple independent sources?\n\n    5. RECENCY AND RELEVANCE:\n       - Is the content recent and relevant to current events?\n       - Is it being reported by multiple sources?\n\n    6. RED FLAGS (lower credibility):\n       - Excessive use of all-caps or emojis\n       - Conspiracy theories without evidence\n       - Clickbait language\n       - Anonymous or new accounts\n       - Overly emotional or sensational language\n\n    Assign a credibility score (0.0 to 1.0) where:\n    - 0.8 - 1.0: Highly credible (verified, well-sourced, consistent)\n    - 0.5 - 0.8: Moderately credible (some verification, reasonable)\n    - 0.2 - 0.5: Low credibility (unverified, some red flags)\n    - 0.0 - 0.2: Not credible (major red flags, contradictory)\n\n    Return as a CredibilityAssessment object with:\n    - post_id: Identifier for the post\n    - credibility_score: Float between 0.0 and 1.0\n    - factors: Array of key factors that influenced the score\n    - reasoning: Explanation for the assigned score\n  \"#\n}\n\nfunction DetectMisinformation(text: string) -> MisinformationAnalysis {\n  client GeminiFlash\n  prompt #\"\n    Analyze this text for potential misinformation patterns:\n\n    {{ text }}\n\n    Look for these suspicious patterns:\n\n    1. EMOTIONAL MANIPULATION:\n       - Exaggerated emotional language\n       - Fear-mongering\n       - Urgency (\"share this now!\")\n\n    2. MISLEADING HEADLINES:\n       - Clickbait titles\n       - Missing critical context\n       - Out-of-context quotes\n\n    3. SOURCE ISSUES:\n       - Anonymous claims without attribution\n       - \"Sources say\" without specifying\n       - Citing unreliable sources\n\n    4. FACTUAL INACCURACIES:\n       - Inconsistent timestamps\n       - Impossible claims\n       - Contradicts basic facts\n\n    5. NARRATIVE PATTERNS:\n       - Conspiracy theories\n       - \"They don't want you to know\" framing\n       - Over-simplification of complex issues\n\n    Assess risk level:\n    - LOW: No obvious red flags, minor issues\n    - MEDIUM: Some concerning patterns, verify before sharing\n    - HIGH: Multiple red flags, likely misinformation\n\n    Return as JSON with:\n    - is_suspicious: Boolean\n    - suspicious_patterns: Array of detected patterns\n    - risk_level: One of \"low\", \"medium\", or \"high\"\n    - recommendation: Action to take (verify, ignore, report, etc.)\n  \"#\n}\n\nfunction GenerateRecommendations(query: string, timeline: Timeline?, user_session: SessionMemory[]?) -> Recommendation[] {\n  client GeminiFlash\n  prompt #\"\n    Given this query and timeline:\n\n    QUERY: {{ query }}\n\n    {% if timeline %}\n    TIMELINE SUMMARY:\n    Topic: {{ timeline.topic }}\n    Events: {{ timeline.events.length }}\n    Avg Credibility: {{ timeline.avg_credibility }}\n    Sources: {{ timeline.total_sources }}\n    {% endif %}\n\n    {% if user_session %}\n    USER'S RECENT QUERIES:\n    {% for mem in user_session %}\n    - {{ mem.query }} (relevance: {{ mem.relevance_score }})\n    {% endfor %}\n    {% endif %}\n\n    Generate 3-5 context-aware recommendations for follow-up actions.\n    Consider:\n\n    1. DEEP DIVE OPPORTUNITIES:\n       - Are there events that need more investigation?\n       - Are there gaps in the timeline?\n       - Are there unverified claims to explore?\n\n    2. RELATED TOPICS:\n       - What related events or topics might the user be interested in?\n       - What happened before/after this timeline?\n       - What related locations or people are involved?\n\n    3. FACT-CHECKING SUGGESTIONS:\n       - Are there claims that should be verified against official sources?\n       - Are there contradictory accounts that need reconciliation?\n\n    4. PREDICTIVE INSIGHTS:\n       - Based on patterns, what might happen next?\n       - What should the user watch for?\n\n    5. USER INTEREST ALIGNMENT:\n       - Based on their recent queries, what else might interest them?\n\n    Return as an array of Recommendation objects, each with:\n    - action: Specific action or follow-up query\n    - reason: Why this is being recommended\n  \"#\n}",
    "simple_test.baml": "class SimpleEvent {\n  id string\n  summary string\n}\n\nfunction SimpleTest() -> SimpleEvent {\n  client \"openai/gpt-4o-mini\"\n  \n  prompt #\"\n    Create a simple event with id and summary.\n  \"#\n}\n",
}

def get_baml_files():
    return _file_map